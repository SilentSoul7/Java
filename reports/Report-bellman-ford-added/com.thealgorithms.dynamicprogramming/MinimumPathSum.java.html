<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="sv"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MinimumPathSum.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Java</a> &gt; <a href="index.source.html" class="el_package">com.thealgorithms.dynamicprogramming</a> &gt; <span class="el_source">MinimumPathSum.java</span></div><h1>MinimumPathSum.java</h1><pre class="source lang-java linenums">package com.thealgorithms.dynamicprogramming;

/*
Given the following grid with length m and width n:
\---\---\---\ (n)
\ 1 \ 3 \ 1 \
\---\---\---\
\ 1 \ 5 \ 1 \
\---\---\---\
\ 4 \ 2 \ 1 \
\---\---\---\
(m)
Find the path where its sum is the smallest.

The Time Complexity of your algorithm should be smaller than or equal to O(mn).
The Space Complexity of your algorithm should be smaller than or equal to O(n).
You can only move from the top left corner to the down right corner.
You can only move one step down or right.

EXAMPLE:
INPUT: grid = [[1,3,1],[1,5,1],[4,2,1]]
OUTPUT: 7
EXPLANATIONS: 1 + 3 + 1 + 1 + 1 = 7

For more information see https://www.geeksforgeeks.org/maximum-path-sum-matrix/
 */
public final class MinimumPathSum {

    private MinimumPathSum() {
    }

    public static int minimumPathSum(final int[][] grid) {
<span class="fc" id="L33">        int numRows = grid.length;</span>
<span class="fc" id="L34">        int numCols = grid[0].length;</span>

<span class="fc bfc" id="L36" title="All 2 branches covered.">        if (numCols == 0) {</span>
<span class="fc" id="L37">            return 0;</span>
        }

<span class="fc" id="L40">        int[] dp = new int[numCols];</span>

        // Initialize the first element of the dp array
<span class="fc" id="L43">        dp[0] = grid[0][0];</span>

        // Calculate the minimum path sums for the first row
<span class="fc bfc" id="L46" title="All 2 branches covered.">        for (int col = 1; col &lt; numCols; col++) {</span>
<span class="fc" id="L47">            dp[col] = dp[col - 1] + grid[0][col];</span>
        }

        // Calculate the minimum path sums for the remaining rows
<span class="fc bfc" id="L51" title="All 2 branches covered.">        for (int row = 1; row &lt; numRows; row++) {</span>
            // Update the minimum path sum for the first column
<span class="fc" id="L53">            dp[0] += grid[row][0];</span>

<span class="fc bfc" id="L55" title="All 2 branches covered.">            for (int col = 1; col &lt; numCols; col++) {</span>
                // Choose the minimum path sum from the left or above
<span class="fc" id="L57">                dp[col] = Math.min(dp[col - 1], dp[col]) + grid[row][col];</span>
            }
        }

        // Return the minimum path sum for the last cell in the grid
<span class="fc" id="L62">        return dp[numCols - 1];</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>